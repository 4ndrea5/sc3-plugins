{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf420
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fnil\fcharset77 Monaco;\f2\fswiss\fcharset77 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red191\green0\blue0;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\b\fs36 \cf0 Logger
\fs26 	Store values to a buffer, whenever triggered
\f1\b0\fs18 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\b\fs24 \cf0 	Logger.kr(in, trig, bufnum, reset)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f1\b0\fs18 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f2\fs24 \cf0 Writes a series of (control-rate) values to a [\ul Buffer\ulnone ], storing them strictly sequentially. Whenever 
\f0\b trig
\f2\b0  crosses from non-positive to positive,  the current value of the input will be written to the buffer. Storage starts at the buffer beginning and increments the write position until the buffer is full. If 
\f0\b reset
\f2\b0  crosses from non-positive to positive, then the buffer will be zero'ed (all values set to zero) and the next write will begin again at the first entry.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\b \cf0 in
\f2\b0  can be an array - it should be of the same size as the number of channels in the buffer.\
\

\f0\b NB: 
\f2\b0 Logger 
\f0\b zeroes the buffer upon first instantiation
\f2\b0 , to ensure that out-of-date data is not confused with new data. So it will definitely clobber any data you may have had in the buffer before it runs. It makes no sense to use multiple instances of Logger on the same buffer, since data will be overwritten.\
\

\f0\b Examples\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f2\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f1\fs18 \cf0 s.boot;\
b = \cf2 Buffer\cf0 .alloc(s, 100);\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf3 // This example simply stores values regularly sampled from an oscillator.\cf0 \
\cf3 // With such a small buffer, it doesn't take long to fill up.\cf0 \
\cf3 // Note what happens when full.\cf0 \
x = \{\
	\cf2 var\cf0  source;\
	source = \cf2 LFCub\cf0 .kr(10, 0, \cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .linen(1, 2, 1), doneAction:2));\
	\cf2 Logger\cf0 .kr(source, \cf2 Impulse\cf0 .kr(49), b.bufnum);\
\}.play(s);\
)\
b.plot;\
\
\
(\
\cf3 // This time we'll trigger something to create and store random values, and recall them later.\cf0 \
x = \{ \cf2 |t_trig=0, t_reset=0|\cf0 \
	\cf2 var\cf0  source;\
	source = \cf2 LFNoise0\cf0 .kr(10);\
	source.poll(t_trig, \cf4 "Storing this random value"\cf0 );\
	\cf2 Logger\cf0 .kr(source, t_trig, b.bufnum, t_reset);\
\}.play(s);\
)\
x.set(\cf5 \\t_trig\cf0 , 1); \cf3 // Call this a few times\cf0 \
b.loadToFloatArray(action:\{\cf2 |ar|\cf0  ar.postcs\}) \cf3 // Dump the values\cf0 \
x.set(\cf5 \\t_reset\cf0 , 1); \cf3 // When you want to start from scratch\cf0 \
}