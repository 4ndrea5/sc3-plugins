{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf420
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;\f2\fswiss\fcharset77 Helvetica-BoldOblique;
\f3\fnil\fcharset77 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue191;\red0\green115\blue0;\red191\green0\blue0;
\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs36 \cf0 ProcMod	/ ProcEvents		
\fs30 A real-time control structure!
\f1\b0\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 ProcMod - A structure for controlling modular processes.\
ProcEvents - An event manager for ProcMod with GUI control capabilities.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs32 \cf0 ProcMod\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 \
Class Methods\
\
*new(env, amp, id, group, addAction, target, function, releaseFunc, onReleaseFunc, responder,\
		timeScale, lag, clock, server)\
*play(env, amp, id, group, addAction, target, function, releaseFunc, onReleaseFunc, responder,\
		timeScale, lag, clock, server)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
	
\f0\b env - 
\f1\b0 an overall amplitude envelope that synths created in a ProcMod function can access. This will run\
		a .kr env on ProcMod.envbus that can be read by other synths in the ProcMod through the creation\
		of a procmodenv synth. There is a max of 20 breakpoints to the env. If the Env has a releaseNode,\
		ProcMod will continue to process events until .release is called.\
	
\f0\b amp - 
\f1\b0 an overall amplitude control for an instance of ProcMod.\
	
\f0\b id - 
\f1\b0 a \\symbol or "string" to be used later to identify an instance of ProcMod.\
	
\f0\b group - 
\f1\b0 a group for an instance of ProcMod to run in. Defaults to nil and a new group is created. If \
		ProcMod creates the group, a new one is created on each .play call.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 	addAction - 
\f1\b0 an addAction for this instance of ProcMod. Defaults to 0.\
	
\f0\b target -
\f1\b0  a target for this instance of ProcMod. Defaults to 1.\
	
\f0\b function
\f1\b0  - a Function, Task or Routine to be evaluated on the playing of this instance of ProcMod.\
		If a Function is passed in that returns a Task or Routine, the ProcMod will become 're-triggerable'\
		and will allow for overlapping getures (it can be released and restarted immediately). All Functions,\
		when evaluated, will have the current group id and envbus passed in as an argument.\
	
\f0\b releaseFunc
\f1\b0  - a Function, Task or Routine to be evaluated after the ProcMod has finished its release\
	
\f0\b onReleaseFunc
\f1\b0  - a Function, Task or Routine to be evaluated at release time.\
	
\f0\b responder
\f1\b0  -  an instance of OSCresponder or OSCresponderNode for use by this instance \
		of ProcMod. It is automatically added when the ProcMod starts, and released after the ProcMod\
		finishes its release.\
	
\f0\b timeScale -
\f1\b0  applies a scale function to the ProcMod envelope. Defaults to 1.\
	
\f0\b lag -
\f1\b0  applies to chages to the amp value passed into this instance of ProcMod.\
	
\f0\b clock -
\f1\b0  an intance of Clock to run this instance of ProcMod. Defaults to SystemClock.\
	
\f0\b server -
\f1\b0  an instance of Server to run this ProcMod on. Useful for remote servers. \
		Defaults to Server.default.\
	\
\

\f0\b Instance methods\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 play - 
\f1\b0 evaluates this instance of ProcMod. ProcMod.function is evaluated, and ProcMod.responder is set up\
	if they are declared.\
	\

\f0\b value - 
\f1\b0 same as .play.\
\

\f0\b release - 
\f1\b0 releases an instance of ProcMod. If ProcMod.env has a release section, functions and\
	OSCresponders wait until this has executed before releasing the ProcMods functionality.\
	\

\f0\b kill - 
\f1\b0 immediately free the ProcMod, regardless of ProcMod.env.\
\

\f0\b group -
\f1\b0  return the current group of this instance of ProcMod.\
\

\f0\b envbus - 
\f1\b0 return the current control bus id the global envelope is written to for this instance of ProcMod.\
	\

\f0\b env_( Env or Number) -
\f1\b0  an instance of Env to be sent to the synthdef controlling an instance of ProcMods \
	overall amplitude and event control. If a Number is passed in, it will represent a releasetime for the \
	ProcMod.\
	
\f0\b \
function_( func ) 
\f1\b0 - an instance of Function, Task or Routine to be evaluated on ProcMod.play. If a Function is \
	passed in, the ProcMod will become 're-triggerable' and can be restarted after it has been released. If\
	a Function is passed in, it may return a Task or Routine. The function is passed the ProcMod's current\
	group and envbus as args.\

\f0\b \
releaseFunc_( func ) 
\f1\b0  - an instance of Function, Task or Routine to be evaluated after a ProcMod has released.\

\f0\b \
onReleaseFunc_( func ) 
\f1\b0  - an instance of Function, Task or Routine to be evaluated the moment a ProcMod is\
 	released.\

\f0\b \
responder_( OSCresponder) 
\f1\b0 - an instance of OSCresponder or OSCresponderNode for use by an instance \
	of ProcMod.\
\

\f0\b amp_( val ) - 
\f1\b0  If there is an envelope controlling the overall amplitude of events, set the amplitude to val.\
\

\f0\b lag_( val ) - 
\f1\b0  If there is an envelope controlling the overall amplitude of events, set the lag time for changes of \
	amplitude to take effect (with the amp_ instance method)\
	\

\f0\b data_( Association ) - 
\f2\i  
\f1\i0\b0 places the Association into a Dictionary for later access. Any Association may be \
	stored. \
	\

\f0\b Examples:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf0 \
\cf2 SynthDef\cf0 (\cf3 \\singrain\cf0 , \{\cf2 arg\cf0  freq, amp, dur, envbus;\
	\cf2 OffsetOut\cf0 .ar(0, \
		\cf2 Pan2\cf0 .ar(\
			\cf2 SinOsc\cf0 .ar(freq, 0, amp) * \
				\cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .sine(dur, amp), doneAction: 2) *\
				\cf2 In\cf0 .kr(envbus),\
			-1.0.rrand(1.0)\
		)\
	) \cf4 // read off the overall env control of the ProcMod\cf0 \
\}).load(s);\
	\
\cf4 // create a new proc mod, and assign a function to it\cf0 \
a = \cf2 ProcMod\cf0 .new(\cf2 Env\cf0 ([0, 1, 0], [1, 1], \cf3 \\sin\cf0 , 1), server: s);\
a.function_(\
	\cf2 Task\cf0 (\{\
		\cf2 inf\cf0 .do\{\
			\cf4 // start a new synth... run it inside this ProcMod's group,\cf0 \
			\cf4 // and read control values off the envbus\cf0 \
			a.server.sendMsg(\cf3 \\s_new\cf0 , \cf3 \\singrain\cf0 , a.server.nextNodeID, 0, a.group,\
				\cf3 \\freq\cf0 , 440.rrand(1760), \cf3 \\amp\cf0 , 0.1, \cf3 \\dur\cf0 , 5, \cf3 \\envbus\cf0 , a.envbus);\
			0.5.wait;\
			\}\
		\});\
	);\
\cf4 \
// play it\cf0 \
a.play;\
\cf4 // change the amp\cf0 \
a.amp_(2);\
\cf4 // change the lag\cf0 \
a.lag_(0.5);\
\cf4 // change the amp again\cf0 \
a.amp_(5);\
\cf4 // release it\cf0 \
a.release;\
\
\cf4 // creating ProcMods in a functional way\cf0 \
\
a = \{\cf2 arg\cf0  amp, env, high, low, winsize, overlaps;\
	\cf2 var\cf0  proc;\
	proc = \cf2 ProcMod\cf0 .new(env, amp);\
	proc.function_(\
		\cf2 Task\cf0 (\{\
			\cf2 inf\cf0 .do\{\
				\cf4 // start a new synth... run it inside this ProcMod's group,\cf0 \
				\cf4 // and read control values off the envbus\cf0 \
				s.sendMsg(\cf3 \\s_new\cf0 , \cf3 \\singrain\cf0 , s.nextNodeID, 0, proc.group,\
					\cf3 \\freq\cf0 , high.rrand(low), \cf3 \\amp\cf0 , 1, \cf3 \\dur\cf0 , winsize, \
					\cf3 \\envbus\cf0 , proc.envbus);\
				(winsize / overlaps).wait;\
				\}\
			\});\
		);\
	\};\
\
\cf4 // create new instances of ProcMod... store it to the variables 'b' and 'c'\cf0 \
b = a.value(0.2, \cf2 Env\cf0 ([0, 1, 0], [1, 1], \cf3 \\sin\cf0 , 1), 2000, 1000, 0.1, 4);\
c = a.value(0.3, \cf2 Env\cf0 ([0, 1, 0], [10, 0.1], [5, -10], 1), 440, 880, 0.4, 2);\
\
b.play; c.play;\
\
b.release; \
c.release;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 Re-triggerable ProcMods\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 ProcMods are meant for the most part, to be played and released. However, if the function slot is passed a Function object, they can be re-triggered after they have been released. If the Function returns a Task or Routine, the ProcMod will function as though a Task or Routine were placed in the function slot (it will be started and released in the same way). Re-triggered events will be assigned a new group and envbus, so these are made available to the Function through arguments. If an OSCresponderNode or releaseFunc are needed for each re-triggered event, they should be assigned inside the Function:\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3 \cf2 SynthDef\cf0 (\cf3 \\trig\cf0 , \{\cf2 arg\cf0  id, val;\
	\cf2 SendTrig\cf0 .kr(\cf2 Impulse.kr(10)\cf0 , id, val);\
	\}).load(s);\
	\
\cf2 SynthDef\cf0 (\cf3 \\singrain\cf0 , \{\cf2 arg\cf0  freq, amp, dur, envbus;\
	\cf2 OffsetOut\cf0 .ar(0, \
		\cf2 Pan2\cf0 .ar(\
			\cf2 SinOsc\cf0 .ar(freq, 0, amp) * \
				\cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .sine(dur, amp), doneAction: 2) *\
				\cf2 In\cf0 .kr(envbus),\
			-1.0.rrand(1.0)\
		)\
	) \cf4 // read off the overall env control of the ProcMod\cf0 \
\}).load(s);\
\
i = 0;\
s.boot;\
a = \cf2 ProcMod\cf0 .new(\cf2 Env\cf0 ([0, 1, 0], [1, 3], \cf3 \\sin\cf0 , 1), server: s);\
\cf4 // use a function. This one returns the Task. group and envbus are passed in as args\cf0 \
a.function_(\{arg group, envbus, server;\
	a.responder_(\
			OSCresponderNode(a.server.addr, '/tr', \{arg time, resp, msg;\
				(msg[2] == group).if(\{msg[3].postln\})\
				\})\
		);\
	\cf2 Task\cf0 (\{\
		s.sendMsg(\cf3 \\s_new\cf0 , \cf3 \\trig\cf0 , a.server.nextNodeID, 0, group, \cf3 \\id\cf0 , group,\
			\\val, i);\
		i = i + 1;\
		\cf2 inf\cf0 .do(\{\
			\cf4 // start a new synth... run it inside this ProcMod's group,\cf0 \
			\cf4 // and read control values off the envbus\cf0 \
			a.server.sendMsg(\cf3 \\s_new\cf0 , \cf3 \\singrain\cf0 , a.server.nextNodeID, 0, \
				group, \cf3 \\freq\cf0 , 440.rrand(880) * i, \cf3 \\amp\cf0 , 0.1, \cf3 \\dur\cf0 , 5, \
				\cf3 \\envbus\cf0 , envbus);\
			0.05.wait;\
			\});\
		\});\
	\});\
	\
a.play; \cf4 // play the ProcMod\cf0 \
\cf4 // release the current event, and start a new one immediately. These will overlap.\cf0 \
a.release; a.play; // watch the posted values from the OSCresponderNode\
a.release;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs32 \cf0 ProcEvents\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs24 \cf0 Class Methods\
\
*new(events, amp, initmod, killmod, id, server)\
\
	events -
\f1\b0  an array of events (ProcMods or a function) to play / release  in the following format:\
			[ProcMod, ProcMod.id to release]\
		both the events to play and release may also be arrays, or nil.\
		If the event is a function, realize that it is best to be a single shot type of thing, you won't be able to\
		access it later (to stop a loop, for instance). So, make sure it is something that you set to run\
		or execute, then can forget about completely.\
	
\f0\b amp - 
\f1\b0 an amplitude scaler for everything running in the ProcEvents instance.\
	
\f0\b initmod -
\f1\b0  a ProcMod to be evaluated when the first event is called, regardless of event number. Useful for\
		allocating buffers or persistant synths.\

\f0\b 	killmod - 
\f1\b0 a ProcMod to be evaluated when this instance of ProcEvents is killed. Useful for freeing buffers\
		and killing persistant synths.\

\f0\b 	id - 
\f1\b0 a \\symbol or "string" to identify this instance of ProcEvents\
	
\f0\b server -
\f1\b0  an instance of Server to run this ProcMod on. Useful for remote servers. \
		Defaults to Server.default.	\
\

\f0\b Instance methods\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f1\b0 \cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b \cf0 play( eventindex ) -
\f1\b0  plays and releases the events at index in the events array. If initmod has not been \
	executed, it will be.\
\

\f0\b next - 
\f1\b0 will play and release the next event is the events array. Starts at 0. If initmod has not been executed, it\
	will be.\
	\

\f0\b releaseAll -
\f1\b0  releases all running ProcMods EXCEPT the initmod.\
\

\f0\b reset - 
\f1\b0 releases all running ProcMods and resets the system to evaluate initmod again.\
\

\f0\b killAll - 
\f1\b0 kill this instance of ProcEvents. Frees everything.\
\

\f0\b starttime( id ) - 
\f1\b0 returns the starttime of the ProcMod with 'id' in relation to the starttime of ProcEvents' first event. \
	d should be a \\symbol or "string". If 'id' is nil, the time of the first event of this instance of ProcEvents\
	(according to Main.elapsedTime) is returned.\
	\

\f0\b now( id ) -
\f1\b0  returns the current time in reference to the starttime of 'id'. 'id' should be a \\symbol or "string". If 'id' is \
	nil, the reference will be the ProcEvents starttime itself.\
	\

\f0\b perfGUI - 
\f1\b0 creates a GUI with basic ProcEvents controls to perform an instance of ProcEvents. \
\

\f0\b pracGUI - 
\f1\b0 creates a GUI with basic ProcMod controls and a perfGUI for rehearsal purposes.\
	\

\f0\b pedalTrig( pedalbus, headroom, trigwindow, testdur ) - 
\f1\b0 listens to pedalbus for Amplitude triggers. This is \
	fairly specialized. I use a quater inch keyboard sustain pedal (a ground switch). When pedalTrig is \
	invoked, an OSCresponderNode is started that listens for a noise floor for testdur seconds. An average \
	reading is taken and is stored as a basevalue. When the pedal is pressed, a spike in amplitude is created. \
	If the spike is within basevalue * headroom, the next event is called. Some tuning should be done to find\
	a headroom value that will work reliably. Triggers are limited to one trigger in every trigwindow seconds.\
	The server MUST be booted before .pedalTrig is called.\
\

\f0\b TO DO: create a way to store values from the pracGUI to be re-used for later performances.\
\
Examples:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f3\b0 \cf2 SynthDef\cf0 (\cf3 \\singrain\cf0 , \{\cf2 arg\cf0  freq, amp, dur, procbus;\
	\cf2 Out\cf0 .ar(0, \
		\cf2 Pan2\cf0 .ar(\
			\cf2 SinOsc\cf0 .ar(freq, 0, amp) * \
				\cf2 EnvGen\cf0 .kr(\cf2 Env\cf0 .sine(dur, amp), doneAction: 2) *\
				\cf2 In\cf0 .kr(procbus),\
			-1.0.rrand(1.0)\
		)\
	) \cf4 // read off the overall env control of the ProcMod\cf0 \
\}).load(s);\
\
(\
\cf4 // create a ProcMod... feed the function in at init time\cf0 \
a = \cf2 ProcMod\cf0 .new(\cf2 Env\cf0 ([0, 1, 0], [1, 1], \cf3 \\sin\cf0 , 1), 0.02)\
	.function_(\{arg group, envbus;\
			\cf2 Task\cf0 (\{\
				\cf2 inf\cf0 .do\{\
					s.sendMsg(\cf3 \\s_new\cf0 , \cf3 \\singrain\cf0 , s.nextNodeID, 0, group,\
						\cf3 \\freq\cf0 , 440.rrand(880), \cf3 \\amp\cf0 , 1, \cf3 \\dur\cf0 , 0.2, \
						\cf3 \\procbus\cf0 , envbus);\
					0.05.wait;\
					\}\
				\});\
			\});\
\
\cf4 // create a ProcMod... set the function after init time\cf0 \
b = \cf2 ProcMod\cf0 .new(\cf2 Env\cf0 ([0, 1, 0], [1, 1], \cf3 \\sin\cf0 , 1), 0.02)\
	.function_(\{arg group, envbus;\
		\cf2 Task\cf0 (\{\
			\cf2 inf\cf0 .do\{\
				s.sendMsg(\cf3 \\s_new\cf0 , \cf3 \\singrain\cf0 , s.nextNodeID, 0, group,\
					\cf3 \\freq\cf0 , 4400.rrand(8800), \cf3 \\amp\cf0 , 1, \cf3 \\dur\cf0 , 0.2, \
					\cf3 \\procbus\cf0 , envbus);\
				0.05.wait;\
				\}\
			\});\
		\});			\
\
\cf4 // create the ProcEvents to run the above ProcMods				\cf0 \
e = \cf2 ProcEvents\cf0 .new(\
	\cf4 // an array of event / release arrays\cf0 \
	[\
		\cf4 // run 'a'\cf0 \
/* 0 */		[a, \cf2 nil\cf0 ],\
		\cf4 // run 'b'\cf0 \
/* 1 */		[b, \cf2 nil\cf0 ],\
		\cf4 // kill ev1 and ev2\cf0 \
/* 2 */		[\cf2 nil\cf0 , [\cf3 a\cf0 , \cf3 b\cf0 ]]\
	], 1);\
\
)\
\
e.perfGUI;\
\
\cf4 // a more complex example, using function to create ProcMods, and feeding the \cf0 \
\cf4 // evaluated form of those functions into ProcEvents.\cf0 \
(\
a = \{\cf2 arg\cf0  id, amp, env, high, low, winsize, overlaps;\
	\cf2 var\cf0  proc;\
	proc = \cf2 ProcMod\cf0 .new(env, amp, id: id);\
	proc.function_(\{arg group;\
		\cf2 Task\cf0 (\{\
			\cf2 inf\cf0 .do\{\
				\cf4 // start a new synth... run it inside this ProcMod's group,\cf0 \
				\cf4 // and read control values off the envbus\
\cf0 				s.sendMsg(\cf3 \\s_new\cf0 , \cf3 \\singrain\cf0 , s.nextNodeID, 0, group,\
					\cf3 \\freq\cf0 , high.rrand(low), \cf3 \\amp\cf0 , 1, \cf3 \\dur\cf0 , winsize, \
					\cf3 \\procbus\cf0 , proc.envbus);\
				(winsize / overlaps).wait;\
				\}\
			\});\
		\});\
	\};\
\
e = \cf2 ProcEvents\cf0 .new([\
\cf4 /* 0 */\cf0 		[a.value(\cf3 \\ev1\cf0 , 0.1, \cf2 Env\cf0 ([0, 1, 0], [2, 10], \cf3 \\sin\cf0 , 1), 440, 880, 0.3, 8),\
			\cf2 nil\cf0 ], \cf4 // create \\ev1, release nothing\cf0 \
\cf4 /* 1 */\cf0 		[a.value(\cf3 \\ev2\cf0 , 0.1, \cf2 Env\cf0 ([0, 1, 0], [1, 10], \cf3 \\sin\cf0 , 1), 2200, 4400, 0.2, 8),\
			\cf2 nil\cf0 ],\
\cf4 /* 2 */\cf0 		[a.value(\cf3 \\ev3\cf0 , 0.1, \cf2 Env\cf0 ([0, 1, 0.5, 2, 0], [1, 1, 1, 1], \cf3 \\sin\cf0 , 1), 100,\
				10000, 1, 4),\
			[\cf3 \\ev1\cf0 , \cf3 \\ev2\cf0 ]], \cf4 // release ev1 and ev2\cf0 \
\cf4 /* 3 */\cf0 		[\cf2 nil\cf0 , \cf3 \\ev3\cf0 ]\
			], 0.dbamp, id: \cf5 "test"\cf0 );\
			\
)\
\
e.perfGUI;\
\
\cf4 /* A simple example showing the pedalTrig function. The headroom value is high so you\
can see how it works with an internval mic ... snap your fingers and the GUI should advance */\cf0 \
\
(\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf0 s=Server.internal.boot;\
s.waitForBoot(\{\
	a = \cf2 ProcEvents\cf0 .new([\
		[\{\cf5 "event1"\cf0 .postln\}, \cf2 nil\cf0 ],\
		[\{\cf5 "event2"\cf0 .postln\}, \cf2 nil\cf0 ],\
		[\{\cf5 "event3"\cf0 .postln\}, \cf2 nil\cf0 ],\
		[\{\cf5 "event4"\cf0 .postln\}, \cf2 nil\cf0 ],\
		[\{\cf5 "event5"\cf0 .postln\}, \cf2 nil\cf0 ],\
		[\{\cf5 "event6"\cf0 .postln\}, \cf2 nil\cf0 ],\
		[\{\cf5 "event7"\cf0 .postln\}, \cf2 nil\cf0 ],\
		[\{\cf5 "event8"\cf0 .postln\}, \cf2 nil\cf0 ],\
		[\{\cf5 "event9"\cf0 .postln\}, \cf2 nil\cf0 ]\
		], 1, \cf2 nil\cf0 , \cf2 nil\cf0 , \cf5 "test"\cf0 , s);\
		\
	\cf4 // .pedalTrig(pedalbus, tolerance, testdur)\cf0 \
	\cf4 // we'll make the pedalbus the inbus of the pedal\cf0 \
	\cf4 // pedalTrig will listen for the average amount of noise on the bus\cf0 \
	\cf4 // then looks for triggers above noise * headroom\cf0 \
	\cf4 // 5 might be high... but it is handy for using the internal mic for a test\
	// this really depends on the noise floor of your pedal (I've used values in \
	// the hundreds even)\cf0 \
	a.pedalTrig(s.options.numOutputBusChannels, 10, 2);\
	\
	a.perfGUI;\
	\})\
)\
\
s.scope}